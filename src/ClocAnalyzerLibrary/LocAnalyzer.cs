using System;
using System.Collections.Generic;
using System.Diagnostics;
using System.IO;
using System.Text.RegularExpressions;

namespace ClocAnalyzerLibrary
{
    public static class LocAnalyzer
    {
        public static FolderStats Analyze(LocAnalyzerSettings settings)
        {
            var csvDelimiter = ';';
            var rootFolder = new FolderStats { FullPath = settings.RootPath };
            var arguments = new List<string>();
            arguments.Add("--csv");
            arguments.Add($"--csv-delimiter={csvDelimiter}");
            arguments.Add("--by-file");
            arguments.Add("--quiet");
            bool hasClocOptions = !string.IsNullOrWhiteSpace(settings.ClocOptions);
            var optionsTempFile = Path.GetTempFileName();
            if (hasClocOptions)
            {
                // Write the options to a temporary file and use it
                File.WriteAllText(optionsTempFile, settings.ClocOptions);
                arguments.Add($@"--config=""{optionsTempFile}""");
            }
            // Create and use a temporary file for the ignored files list
            var ignoredTempFile = Path.GetTempFileName();
            arguments.Add($@"--ignored=""{ignoredTempFile}""");
            // Add the root path to be analyzed
            arguments.Add($@"""{settings.RootPath}""");
            // Execute the external application
            var exitCode = ExecuteCmd(settings.ClocExePath, settings.RootPath, string.Join(" ", arguments), out var lines);
            if (exitCode != null && exitCode != 0)
            {
                throw new Exception($"cloc failed with exit code: {exitCode}");
            }
            // Handle the output
            foreach (var line in lines[2..^1])
            {
                var parts = line.Split(csvDelimiter);
                var type = parts[0];
                var filePath = parts[1];
                var blank = parts[2];
                var comment = parts[3];
                var code = parts[4];

                // Customized handling
                if (filePath.EndsWith(".cs", StringComparison.InvariantCultureIgnoreCase))
                {
                    using (var reader = new StreamReader(filePath))
                    {
                        for (int i = 0; i < 2; i++)
                        {
                            var fileLine = reader.ReadLine();
                            if (fileLine != null && fileLine.Contains("<auto-generated>"))
                            {
                                type = "C# Generated";
                                break;
                            }
                        }
                    }
                }

                // Create and add the stats
                var fileStats = new FileStats(type, Convert.ToInt64(code), Convert.ToInt64(comment), Convert.ToInt64(blank))
                {
                    FullPath = filePath
                };
                rootFolder.AddFile(fileStats);
            }

            // Now parse the ignored files            
            if (File.Exists(ignoredTempFile))
            {
                var ignoredLines = File.ReadAllLines(ignoredTempFile);
                foreach (var line in ignoredLines)
                {
                    if (string.IsNullOrWhiteSpace(line))
                    {
                        // Empty entry
                        continue;
                    }
                    var linePrepared = line.Replace("/", "\\");
                    var parts = linePrepared.Split(',', 2);
                    var filePath = parts[0].Trim('\\', '/');
                    if (string.IsNullOrWhiteSpace(filePath))
                    {
                        // Root folder
                        continue;
                    }
                    var reason = parts[1];
                    if (Directory.Exists(filePath))
                    {
                        // Skip directories
                        continue;
                    }
                    var fileStats = new FileStats(reason) { FullPath = filePath };
                    rootFolder.AddFile(fileStats);
                }
            }

            // Cleanup
            if (File.Exists(optionsTempFile))
            {
                File.Delete(optionsTempFile);
            }
            if (File.Exists(ignoredTempFile))
            {
                File.Delete(ignoredTempFile);
            }

            return rootFolder;
        }

        public static int? ExecuteCmd(string cmd, string workingDirectory, string arguments, out string[] outputLines)
        {
            var processInfo = new ProcessStartInfo
            {
                FileName = cmd,
                WorkingDirectory = workingDirectory,
                Arguments = arguments,
                CreateNoWindow = true,
                UseShellExecute = false,
                RedirectStandardOutput = true
            };
            var process = Process.Start(processInfo);
            var outputLinesTmp = new List<string>();
            while (!process.StandardOutput.EndOfStream)
            {
                var line = process.StandardOutput.ReadLine();
                outputLinesTmp.Add(line);
            }
            process?.WaitForExit();
            outputLines = outputLinesTmp.ToArray();
            return process?.ExitCode;
        }
    }
}
